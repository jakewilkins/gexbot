defmodule GexbotWeb.GithubHookController do
  use GexbotWeb, :controller

  require Logger

  plug :accepts, ["json"]

  action_fallback GexbotWeb.FallbackController

  def event(%Plug.Conn{assigns: %{webhook_signature: verification_status}} = conn, params) do
    case {signature_header(conn) |> require_webhook_signature?(), verification_status} do
      {false, _} -> dispatch_event(conn, params)
      {true, :verified} -> dispatch_event(conn, params)
      _ -> log_skipped_processing(verification_status, params)
    end

    send_resp(conn, :no_content, "")
  end

  defp dispatch_event(conn, params) do
    {_, event} = conn.req_headers |> Enum.find(fn
                   {"x-github-event", _} -> true
                   {header_name, value} -> false
                 end)

    Gexbot.Github.Events.webhook(event, params)
  end

  defp log_skipped_processing(reason, params) do
    msg = case reason do
      :unsigned -> "Hook event was not signed."
      :invalid  -> "Provided signature was invalid."
      :webhook_secret_not_set -> "A webhook secret was not configured, please set one in config/config.exs"
      [invalid_hmac_sign: algo] -> "The signature was generated by an unsupported algorithm: '#{algo}'"
    end
    Logger.log(:debug, "Skipped processing webhook: '#{msg}'")
  end

  defp signature_header(conn) do
    case List.keyfind(conn.req_headers, "x-hub-signature", 0) do
      nil -> false
      {_, header} -> true
    end
  end

  defp require_webhook_signature?(has_header) do
    if configured_webhook_secret == nil && !has_header, do: false, else: true
  end

  defp configured_webhook_secret do
    Application.get_env(:gexbot, :webhook_secret, :webhook_secret_not_set)
  end
end
